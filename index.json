[{"uri":"http://wedgevine.github.io/system/python/","title":"python","tags":[],"description":"","content":"data type int in python 3, int has no limit, has infinite precision, thus has infinite bits. in case infinity is needed (for init comparison), there are float(\u0026lsquo;inf\u0026rsquo;), float('-inf\u0026rsquo;) float(\u0026lsquo;nan\u0026rsquo;) can be used as initial value\n  there are articles discussed about python integer object implementation generally, int is implemented as an object, inside the object, there is an array storing every digit of the int, the array length is only limited by memory of machine https://rushter.com/blog/python-integer-implementation/ https://www.laurentluce.com/posts/python-integer-objects-implementation/\n  there is a good explaination in SO, why is \u0026lsquo;1000000 in range(10000000)\u0026rsquo; so fast https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3?rq=1 range() is an object, which has a \u0026lsquo;contain\u0026rsquo; method, which can calculate if a number is in the range, no need to scan through all numbers in the range\n  ternary \u0026lt;expression 1\u0026gt; if else \u0026lt;expression 2\u0026gt;\nformat function print('value1 {}, value2 {}'.format(value1, value2)) looping Loop over a single list with a regular for-in:\nfor n in numbers: print(n) Loop over multiple lists at the same time with zip:\nfor header, rows in zip(headers, columns): print(\u0026quot;{}: {}\u0026quot;.format(header, \u0026quot;, \u0026quot;.join(rows))) Loop over a list while keeping track of indexes with enumerate:\nfor num, line in enumerate(lines): print(\u0026quot;{0:03d}: {}\u0026quot;.format(num, line)) https://treyhunner.com/2016/04/how-to-loop-with-indexes-in-python/\ncontainer, iterable, iterator, generator and iteration tools: loop, list comprehension, map, filter, all  containers are data structures that holding elements and support membership tests, like list, str, tuple, dict, set containers typically are iterable, many others are iterable as well, like file, socket (often for infinite source of data). an iterable is any object that can return an iterator by calling iter() function for the iterable object iterator, a stateful helper object that will produce the next value when call next() function for it, it is a lazy value factory, only next() call will produce next value a generator is always an iterator, an elegent iterator, not like ordinary iterator object, which has init, next, iter methods, a generator is a function, without return value, but has a \u0026ldquo;yield\u0026rdquo; statement, the call to the generator function will return a generator then this generator could be used as an iterator besides generator function, a generator can also be a generator expression, with syntax like: (expression for item in list if condition) just like a list comprehension iteration tools such as loop, list comprehension, all, filter, map functions can work with these iterable objects specifically, steam objects are better to dealt as an iterable object, a lazy data factory  https://nvie.com/posts/iterators-vs-generators/\n PEP 8 style guide for For sequences, (strings, lists, tuples), use the fact that empty sequences are false.  if not seq: if seq: collections namedtuple https://dbader.org/blog/writing-clean-python-with-namedtuples A good way to view them is to think that namedtuples are a memory-efficient shortcut to defining an immutable class in Python manually.\nfrom collections import namedtuple Point = namedtuple('Point', ['x', 'y']) https://stackoverflow.com/questions/40632750/whats-the-difference-between-enum-and-namedtuple mentioned the benefits of namedtuple, which is used for many objects with same type. object attributes can be accessed by name, instead of by index. point.x, vs point[0]\ndeque a generalization of stack and queue, deque, double-ended queue, support append/pop for either side of the deque with O(1) performance.\n append() add to right side pop() remove from right side appendleft() add to the left side popleft() remove from left side  itertools module  itertools.groupby(iterable, key=None), sort data first https://stackoverflow.com/questions/773/how-do-i-use-itertools-groupby groups = [] uniquekeys = [] data = sorted(data, key=keyfunc) for k, g in groupby(data, keyfunc): groups.append(list(g)) # Store group iterator as a list uniquekeys.append(k)   lambda https://realpython.com/python-lambda/ just amonymous function\nfunction all example, to check if an array a is palindromic:\nreturn all(a[i] == a[-i] for i in range(len(a) // 2)) function all() takes a single parameter with iterable type, the above generator expression is a generator, which is always an iterator and an iterator is always an iterable objec\nreduce import functools functools.reduce( lambda x, ele: x + ele, iterable, init_value ) like: x = init_value for ele in iterable: x += ele\nf function https://realpython.com/python-f-strings/\nclass class Dog: def __init__(self, name): self.name = name self.tricks = [] def add_trick(self, trick): self.tricks.append(trick) to make sure two variables are referring to the same object, using \u0026ldquo;is\u0026rdquo;, for reference equality testing\nf1 = Foo() f2 = Foo() print f1 is f2 "},{"uri":"http://wedgevine.github.io/system/bit/","title":"bitwise","tags":[],"description":"","content":""},{"uri":"http://wedgevine.github.io/system/array/","title":"","tags":[],"description":"","content":""},{"uri":"http://wedgevine.github.io/system/","title":"algo","tags":[],"description":"","content":"this is the index page\n"},{"uri":"http://wedgevine.github.io/system/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://wedgevine.github.io/system/tags/","title":"Tags","tags":[],"description":"","content":""}]